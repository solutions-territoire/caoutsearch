[[{"i":"caoutsearch-ˈkawtˈsɝtʃ","l":"Caoutsearch \\ˈkawt͡ˈsɝtʃ\\","p":["Gem Version CI Status Ruby Style Guide Maintainability Test Coverage","JRuby Truffle Ruby","!! Gem under development before public release !!","Caoutsearch is a new Elasticsearch integration for Ruby and/or Rails. It provides a simple but powerful DSL to perform complex indexing and searching, while securely exposing search criteria to a public and chainable API, without overwhelming your models.","Caoutsearch only supports Elasticsearch 8.x right now. It is used in production in a robust application, updated and maintained for several years at Mon Territoire.","Caoutsearch was inspired by awesome gems such as elasticsearch-rails or search_flip. Depending on your search scenarios, they may better suite your needs."]},{"l":"Documentation","p":["Visit our offical documentation to understand how to use Caoutsearch."]},{"l":"Installation","p":["Add the gem in your Gemfile:"]},{"l":"Overview","p":["Caoutsearch let you create Index and Search classes to manipulate your data :"]},{"l":"Contributing","p":["Don't hesitate to submit your feature/idea/fix in issues","Fork the repository","Create your feature branch","Ensure RSpec & Rubocop are passing","Create a pull request"]},{"i":"tests--lint","l":"Tests & lint","p":["To run RSpec against various version of Rails dependencies:","All of them can be run with:"]},{"i":"license--credits","l":"License & credits","p":["Please see LICENSE for further details.","Contributors: ./graphs/contributors"]}],[{"l":"Getting started"},{"l":"Prerequisites","p":["Caoutsearch requires at least :","Ruby 2.7.x","Rails 6.x","Elasticsearch 8.x"]},{"l":"Installation","p":["Add the gem in your Gemfile:"]},{"l":"Configuration","p":["TODO"]}],[{"i":"todo-mapping--settings","l":"[TODO] Mapping & settings"}],[{"i":"todo-text-analysis","l":"[TODO] Text analysis"}],[{"i":"todo-versionning","l":"[TODO] Versionning"}],[{"i":"todo-properties","l":"[TODO] Properties"}],[{"i":"todo-partial-updates","l":"[TODO] Partial updates"}],[{"i":"todo-eager-loading","l":"[TODO] Eager loading"}],[{"i":"todo-interdependencies","l":"[TODO] Interdependencies"}],[{"i":"todo-queries","l":"[TODO] Queries"}],[{"l":"Filters","p":["Filters declared in the search engine will define how Caoutsearch will build the queries","The main use of filters is to expose a field for search, but they can also be used to build more complex queries:","Caoutsearch different types of filters to handle different types of data or ways to search them:"]}],[{"i":"todo-boolean","l":"[TODO] Boolean"}],[{"i":"todo-default","l":"[TODO] Default"}],[{"i":"todo-geopoint","l":"[TODO] Geopoint"}],[{"i":"todo-match","l":"[TODO] Match"}],[{"i":"todo-range","l":"[TODO] Range"}],[{"l":"Date","p":["For a date filter defined like this:","You can now search the matching index with the published_on criterion:","and the following query will be generated to send to elasticsearch:","The date filter accepts multiple types of arguments :","Dates of various formats are handled:","We also support elasticsearch's date math"]}],[{"i":"todo-full-text-query","l":"[TODO] Full-text query"}],[{"i":"todo-custom-filters","l":"[TODO] Custom filters"}],[{"l":"Contexts","p":["Contexts allows to create search scopes independently of search criteria. Because search criteria may comes from user inputs, contexts offers a way to force search scoping :","Multiple contexts can be passed together or chained:","Current context can used to alter search queries or filters:","Missing contexts doesn't raise an expection and are ignored. It allows you to apply contexts to any searches, whether the context is implemented or not:"]}],[{"i":"todo-orders","l":"[TODO] Orders"}],[{"l":"Aggregations","p":["You can define simple to complex aggregations.","Then you can request one or more aggregations at the same time or chain the aggregate method. The aggregations method will trigger a request and returns a Response::Aggregations.","You can create powerful aggregations using blocks and pass arguments to them.","Only one argument can be passed to an aggregation block. Use an Array or a Hash if you need to pass multiple options.","Finally, you can create a \"catch-all\" aggregation to handle cumbersome behaviors:"]}],[{"l":"Transform aggregations","p":["When using buckets aggregation and/or pipeline aggregation, the path to the expected values can get complicated and become subject to unexpected changes for a public API.","Instead, you can define transformations to provide simpler access to aggregated data:","You can also use transformations to combine multiple aggregations:","This is also usefull to unify the API between different search engines:","Transformations are performed on demand and result is memorized. That means:","the result of transformation is not visible in the Response::Aggregations output.","the block is called only once for the same search instance.","Be careful to avoid using aggregations.aggregation_name inside a transformation block: it can lead to an infinite recursion.","Instead, use the argument passed to the block: it's is a shortcut for response.aggregations which is a Response::Reponse and not a Response::Aggregations.","One last helpful argument is track_total_hits which allows to perform calculations over aggregations using the total_count method without sending a second request. Take a look at Total count to understand why a second request could be performed."]}],[{"l":"Responses","p":["After the request has been sent by calling a method such as load, response or hits, the results is wrapped in a Response::Response class which provides method access to its properties via Hashie::Mash.","Aggregations and suggestions are wrapped in their own respective subclass of Response::Response"]}],[{"l":"Loading records","p":["Use records to load model records.","The search engine will try to load records from a model using the same class name without Search the suffix:","ArticleSearch> Article","Blog::ArticleSearch> Blog::Article","However, you can define an alternative model to load records. This might be helpful when using single table inheritance.","You can also define an alternative model at class level:"]}],[{"l":"Add Caoutsearch to your models","p":["The simplest solution is to add Caoutsearch::Model to your model and the link the appropriate Index and/or Search engines:","If you don't need your models to be Indexable and Searchable, you can include only one of the following two modules:","or","The modules can be safely included in the meta model ApplicationRecord. Indexing & searching features are not available until you call index_with or search_with:"]}],[{"l":"Index multiple records","p":["Import all your records or a restricted scope of records to Elastcisearch.","You can update one or more properties. (see Index Engines to read more about properties):","When reindex is called without properties, it'll import the full document to ES. On the contrary, when properties are passed, it'll only update existing documents. You can control this behavior with the method argument."]}],[{"l":"Index single records","p":["Import a single record.","You can update one or more properties. (see Index Engines to read more about properties):","You can verify if and how documents are indexed. If the document is missing in ES, it'll raise a Elastic::Transport::Transport::Errors::NotFound."]}],[{"l":"Delete documents","p":["You can delete one or more documents. Note: it won't delete records from database, only from the ES indice.","If a record is already deleted from the database, you can still delete its document."]}],[{"l":"Automatic callbacks","p":["Callbacks are not provided by Caoutsearch but they are very easy to add:"]}],[{"i":"todo-asynchronous-methods","l":"[TODO] Asynchronous methods"}],[{"l":"Search API","p":["Searching is pretty simple.","You can chain criteria and many other parameters:"]}],[{"l":"Pagination","p":["Search results can be paginated."]}],[{"l":"Total count","p":["By default ES doesn't return the total number of hits. So, when calling total_count or total_pages a second request might be sent to ES. To avoid a second roundtrip, use track_total_hits:"]}],[{"l":"Iterating results","p":["Several methods are provided to loop through a collection or hits or records. These methods are processing batches in the most efficient way: PIT search_after.","find_each_hit to yield each hit returned by Elasticsearch.","find_each_record to yield each record from your database.","find_hits_in_batches to yield each batch of hits as returned by Elasticsearch.","find_records_in_batches to yield each batch of records from the database.","Example:","The keep_alive parameter tells Elasticsearch how long it should keep the point in time alive. Defaults to 1 minute.","To specifies the size of the batch, use per chainable method or batch_size parameter. Defaults to 1000."]}],[{"l":"Testing with Caoutsearch","p":["Caoutsearch offers few methods to stub Elasticsearch requests. You first need to add webmock to your Gemfile.","Then, add Caoutsearch::Testing::MockRequests to your test suite. The examples below uses RSpec, but it should be compatible with other test framework.","You can then call the following methods:","stub_elasticsearch_search_request accepts an array or records:","It allows to shim the total number of hits returned."]}]]